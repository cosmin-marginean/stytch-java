package com.stytch.java.consumer.api.sessions

// !!!
// WARNING: This file is autogenerated
// Only modify code within MANUAL() sections
// or your changes may be overwritten later!
// !!!

import com.squareup.moshi.JsonAdapter
import com.squareup.moshi.Moshi
import com.squareup.moshi.Types
import com.stytch.java.common.JwtOptions
import com.stytch.java.common.StytchResult
import com.stytch.java.consumer.models.sessions.AuthenticateRequest
import com.stytch.java.consumer.models.sessions.AuthenticateResponse
import com.stytch.java.consumer.models.sessions.GetJWKSRequest
import com.stytch.java.consumer.models.sessions.GetJWKSResponse
import com.stytch.java.consumer.models.sessions.GetRequest
import com.stytch.java.consumer.models.sessions.GetResponse
import com.stytch.java.consumer.models.sessions.RevokeRequest
import com.stytch.java.consumer.models.sessions.RevokeResponse
import com.stytch.java.http.HttpClient
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.future.asCompletableFuture
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.jose4j.jwk.HttpsJwks
import java.util.concurrent.CompletableFuture
public interface Sessions {
    /**
     * List all active Sessions for a given `user_id`. All timestamps are formatted according to the RFC 3339 standard and are
     * expressed in UTC, e.g. `2021-12-29T12:33:09Z`.
     */
    public suspend fun get(data: GetRequest): StytchResult<GetResponse>

    /**
     * List all active Sessions for a given `user_id`. All timestamps are formatted according to the RFC 3339 standard and are
     * expressed in UTC, e.g. `2021-12-29T12:33:09Z`.
     */
    public fun get(data: GetRequest, callback: (StytchResult<GetResponse>) -> Unit)

    /**
     * List all active Sessions for a given `user_id`. All timestamps are formatted according to the RFC 3339 standard and are
     * expressed in UTC, e.g. `2021-12-29T12:33:09Z`.
     */
    public fun getCompletable(data: GetRequest): CompletableFuture<StytchResult<GetResponse>>

    /**
     * Authenticate a session token and retrieve associated session data. If `session_duration_minutes` is included, update
     * the lifetime of the session to be that many minutes from now. All timestamps are formatted according to the RFC 3339
     * standard and are expressed in UTC, e.g. `2021-12-29T12:33:09Z`. This endpoint requires exactly one `session_jwt` or
     * `session_token` as part of the request. If both are included you will receive a `too_many_session_arguments` error.
     */
    public suspend fun authenticate(data: AuthenticateRequest): StytchResult<AuthenticateResponse>

    /**
     * Authenticate a session token and retrieve associated session data. If `session_duration_minutes` is included, update
     * the lifetime of the session to be that many minutes from now. All timestamps are formatted according to the RFC 3339
     * standard and are expressed in UTC, e.g. `2021-12-29T12:33:09Z`. This endpoint requires exactly one `session_jwt` or
     * `session_token` as part of the request. If both are included you will receive a `too_many_session_arguments` error.
     */
    public fun authenticate(data: AuthenticateRequest, callback: (StytchResult<AuthenticateResponse>) -> Unit)

    /**
     * Authenticate a session token and retrieve associated session data. If `session_duration_minutes` is included, update
     * the lifetime of the session to be that many minutes from now. All timestamps are formatted according to the RFC 3339
     * standard and are expressed in UTC, e.g. `2021-12-29T12:33:09Z`. This endpoint requires exactly one `session_jwt` or
     * `session_token` as part of the request. If both are included you will receive a `too_many_session_arguments` error.
     */
    public fun authenticateCompletable(data: AuthenticateRequest): CompletableFuture<StytchResult<AuthenticateResponse>>

    /**
     * Revoke a Session, immediately invalidating all of its session tokens. You can revoke a session in three ways: using its
     * ID, or using one of its session tokens, or one of its JWTs. This endpoint requires exactly one of those to be included
     * in the request. It will return an error if multiple are present.
     */
    public suspend fun revoke(data: RevokeRequest): StytchResult<RevokeResponse>

    /**
     * Revoke a Session, immediately invalidating all of its session tokens. You can revoke a session in three ways: using its
     * ID, or using one of its session tokens, or one of its JWTs. This endpoint requires exactly one of those to be included
     * in the request. It will return an error if multiple are present.
     */
    public fun revoke(data: RevokeRequest, callback: (StytchResult<RevokeResponse>) -> Unit)

    /**
     * Revoke a Session, immediately invalidating all of its session tokens. You can revoke a session in three ways: using its
     * ID, or using one of its session tokens, or one of its JWTs. This endpoint requires exactly one of those to be included
     * in the request. It will return an error if multiple are present.
     */
    public fun revokeCompletable(data: RevokeRequest): CompletableFuture<StytchResult<RevokeResponse>>

    /**
     * Get the JSON Web Key Set (JWKS) for a Stytch Project.
     */
    public suspend fun getJWKS(data: GetJWKSRequest): StytchResult<GetJWKSResponse>

    /**
     * Get the JSON Web Key Set (JWKS) for a Stytch Project.
     */
    public fun getJWKS(data: GetJWKSRequest, callback: (StytchResult<GetJWKSResponse>) -> Unit)

    /**
     * Get the JSON Web Key Set (JWKS) for a Stytch Project.
     */
    public fun getJWKSCompletable(data: GetJWKSRequest): CompletableFuture<StytchResult<GetJWKSResponse>>
}

internal class SessionsImpl(
    private val httpClient: HttpClient,
    private val coroutineScope: CoroutineScope,
    private val jwksClient: HttpsJwks,
    private val jwtOptions: JwtOptions,
) : Sessions {

    private val moshi = Moshi.Builder().build()

    override suspend fun get(data: GetRequest): StytchResult<GetResponse> = withContext(Dispatchers.IO) {
        val asJson = moshi.adapter(GetRequest::class.java).toJson(data)
        val type = Types.newParameterizedType(Map::class.java, String::class.java, Any::class.java)
        val adapter: JsonAdapter<Map<String, Any>> = moshi.adapter(type)
        val asMap = adapter.fromJson(asJson) ?: emptyMap()
        httpClient.get("/v1/sessions", asMap)
    }

    override fun get(data: GetRequest, callback: (StytchResult<GetResponse>) -> Unit) {
        coroutineScope.launch {
            callback(get(data))
        }
    }

    override fun getCompletable(data: GetRequest): CompletableFuture<StytchResult<GetResponse>> =
        coroutineScope.async {
            get(data)
        }.asCompletableFuture()
    override suspend fun authenticate(data: AuthenticateRequest): StytchResult<AuthenticateResponse> = withContext(Dispatchers.IO) {
        val asJson = moshi.adapter(AuthenticateRequest::class.java).toJson(data)
        httpClient.post("/v1/sessions/authenticate", asJson)
    }

    override fun authenticate(data: AuthenticateRequest, callback: (StytchResult<AuthenticateResponse>) -> Unit) {
        coroutineScope.launch {
            callback(authenticate(data))
        }
    }

    override fun authenticateCompletable(data: AuthenticateRequest): CompletableFuture<StytchResult<AuthenticateResponse>> =
        coroutineScope.async {
            authenticate(data)
        }.asCompletableFuture()
    override suspend fun revoke(data: RevokeRequest): StytchResult<RevokeResponse> = withContext(Dispatchers.IO) {
        val asJson = moshi.adapter(RevokeRequest::class.java).toJson(data)
        httpClient.post("/v1/sessions/revoke", asJson)
    }

    override fun revoke(data: RevokeRequest, callback: (StytchResult<RevokeResponse>) -> Unit) {
        coroutineScope.launch {
            callback(revoke(data))
        }
    }

    override fun revokeCompletable(data: RevokeRequest): CompletableFuture<StytchResult<RevokeResponse>> =
        coroutineScope.async {
            revoke(data)
        }.asCompletableFuture()
    override suspend fun getJWKS(data: GetJWKSRequest): StytchResult<GetJWKSResponse> = withContext(Dispatchers.IO) {
        val asJson = moshi.adapter(GetJWKSRequest::class.java).toJson(data)
        val type = Types.newParameterizedType(Map::class.java, String::class.java, Any::class.java)
        val adapter: JsonAdapter<Map<String, Any>> = moshi.adapter(type)
        val asMap = adapter.fromJson(asJson) ?: emptyMap()
        httpClient.get("/v1/sessions/jwks/${data.projectId}", asMap)
    }

    override fun getJWKS(data: GetJWKSRequest, callback: (StytchResult<GetJWKSResponse>) -> Unit) {
        coroutineScope.launch {
            callback(getJWKS(data))
        }
    }

    override fun getJWKSCompletable(data: GetJWKSRequest): CompletableFuture<StytchResult<GetJWKSResponse>> =
        coroutineScope.async {
            getJWKS(data)
        }.asCompletableFuture()
}
